<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Know It All? ‚Äî Player</title>

  <style>
    :root{
      --bg:#070707;
      --border:#232323;
      --text:#f3f3f3;
      --muted:#bdbdbd;
      --orange:#ff7a18;
      --good:#29d17d;
      --bad:#ff4b4b;
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius:20px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 30% -10%, rgba(255,122,24,.18), transparent 60%),
        radial-gradient(900px 600px at 90% 0%, rgba(255,122,24,.10), transparent 65%),
        var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      min-height:100vh;
    }
    .wrap{max-width:820px;margin:0 auto;padding:18px 16px 30px}
    .top{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:10px 12px;border:1px solid var(--border);border-radius:18px;
      background:linear-gradient(180deg, rgba(17,17,17,.85), rgba(10,10,10,.65));
      box-shadow:var(--shadow);
      position:sticky;top:12px;z-index:10;backdrop-filter: blur(10px);
    }
    .brand{display:flex;align-items:center;gap:12px;font-weight:950}
    .logo{
      width:40px;height:40px;border-radius:14px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,154,61,.9), rgba(255,122,24,.35) 40%, rgba(0,0,0,.5) 75%),
        linear-gradient(180deg, rgba(255,122,24,.25), rgba(255,122,24,.06));
      border:1px solid rgba(255,122,24,.35);
      box-shadow: 0 12px 30px rgba(255,122,24,.12);
    }
    .title{
      font-size:22px; /* slightly bigger */
      letter-spacing:.3px;
      line-height:1.05;
    }
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 12px;border-radius:999px;border:1px solid var(--border);
      background:rgba(10,10,10,.6); color:var(--muted); font-weight:900;
    }
    .pill b{color:var(--text)}

    .card{
      margin-top:14px;
      border:1px solid var(--border);
      border-radius: var(--radius);
      background:linear-gradient(180deg, rgba(17,17,17,.75), rgba(9,9,9,.65));
      box-shadow:var(--shadow);
      padding:14px;
    }
    .muted{color:var(--muted)}
    .small{font-size:12px}
    input{
      width:100%; padding:11px 12px;border-radius:14px;
      border:1px solid var(--border);
      background:rgba(8,8,8,.65);
      color:var(--text);
      outline:none;
      font-weight:900;
    }
    .btn{
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(20,20,20,.9), rgba(10,10,10,.85));
      color:var(--text);
      padding:10px 14px;border-radius:14px;
      font-weight:950; cursor:pointer;
      box-shadow: 0 10px 30px rgba(0,0,0,.3);
      transition: transform .08s ease, filter .12s ease, border-color .12s ease;
      user-select:none;
    }
    .btn:hover{filter:brightness(1.12);border-color:rgba(255,122,24,.35)}
    .btn:active{transform:translateY(1px)}
    .btn.orange{
      border-color:rgba(255,122,24,.45);
      background:linear-gradient(180deg, rgba(255,122,24,.22), rgba(10,10,10,.88));
      box-shadow: 0 14px 40px rgba(255,122,24,.12);
    }
    .btn:disabled{opacity:.45;cursor:not-allowed}

    .divider{height:1px;background:rgba(255,255,255,.06);margin:12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .qTitle{font-size:22px;font-weight:950;letter-spacing:.3px;line-height:1.25;margin:8px 0 10px}
    .answers{display:grid;gap:10px;grid-template-columns:1fr}
    .ans{
      text-align:left;border-radius:16px;padding:12px 12px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(16,16,16,.85), rgba(8,8,8,.8));
      cursor:pointer;
      font-weight:950;
      color:var(--text);
      min-height:52px;
      transition: filter .12s ease, border-color .12s ease, transform .08s ease;
      user-select:none;
    }
    .ans:hover{filter:brightness(1.10);border-color:rgba(255,122,24,.30)}
    .ans:active{transform:translateY(1px)}
    .ans.selected{
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(8,8,8,.85));
      border-color: rgba(255,255,255,.35);
    }
    .ans.disabled{cursor:not-allowed;opacity:.35}
    .ans.wrongNow{border-color: rgba(255,75,75,.35); background: linear-gradient(180deg, rgba(255,75,75,.16), rgba(8,8,8,.85));}
    .ans.correctNow{border-color: rgba(41,209,125,.35); background: linear-gradient(180deg, rgba(41,209,125,.18), rgba(8,8,8,.85));}

    .timerBig{font-size:30px;font-weight:950;color:var(--orange);letter-spacing:1px}

    .statusBox{
      margin-top:10px;
      padding:10px 12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(10,10,10,.55);
      font-weight:900;
    }
    .statusBox.good{border-color: rgba(41,209,125,.30)}
    .statusBox.bad{border-color: rgba(255,75,75,.30)}
    .statusBox.orange{
      border-color: rgba(255,122,24,.35);
      background: linear-gradient(180deg, rgba(255,122,24,.14), rgba(10,10,10,.60));
    }

    .powerGrid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .powerBtn{
      border-radius:16px;
      padding:12px 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(10,10,10,.55);
      font-weight:980;
      color: rgba(255,255,255,.85);
      cursor:pointer;
      user-select:none;
      transition: filter .12s ease, transform .08s ease, border-color .12s ease;
      text-align:center;
    }
    .powerBtn:hover{filter:brightness(1.08); border-color: rgba(255,122,24,.25)}
    .powerBtn:active{transform:translateY(1px)}
    .powerBtn.on{
      border-color: rgba(255,122,24,.55);
      background: linear-gradient(180deg, rgba(255,122,24,.18), rgba(10,10,10,.70));
      color:#fff;
    }
    .powerBtn.disabled{
      opacity:.38; cursor:not-allowed; filter:saturate(.6);
    }

    .promptBar{
      margin-top:12px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,122,24,.45);
      background: linear-gradient(180deg, rgba(255,122,24,.18), rgba(8,8,8,.78));
      font-weight:990;
      letter-spacing:.8px;
      text-align:center;
      display:none;
    }

    .rulesBtn{
      position:fixed;right:16px;bottom:16px;z-index:1000;
      border-radius:999px;padding:10px 14px;
      background:linear-gradient(180deg, rgba(255,122,24,.25), rgba(10,10,10,.85));
      border:1px solid rgba(255,122,24,.45);
      font-weight:980;cursor:pointer;
      box-shadow: 0 14px 44px rgba(255,122,24,.12);
      color:#fff;
    }

    .modalBack{
      position:fixed;inset:0;background:rgba(0,0,0,.6);
      display:none;align-items:center;justify-content:center;z-index:999;
      padding:18px;
    }
    .modal{
      width:min(720px, 100%);
      border-radius:22px;
      border:1px solid rgba(255,122,24,.35);
      background: linear-gradient(180deg, rgba(16,16,16,.92), rgba(8,8,8,.90));
      box-shadow: 0 25px 80px rgba(0,0,0,.6);
      padding:14px;
      max-height: 80vh;
      overflow:auto;
    }
    .modal .modalTop{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .note{margin-top:10px;color:var(--muted);font-weight:850;font-size:12px;line-height:1.45}

    /* Leaderboard popup */
    .lbList{display:flex;flex-direction:column;gap:8px;margin-top:10px}
    .lbRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.06);
      background:rgba(10,10,10,.5);
      font-weight:950;
    }
    .lbRow .score{color:var(--orange);font-weight:990}
    .lbRow .mini{font-size:12px;color:var(--muted);font-weight:850}

    /* Sabotage selection */
    .pickRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.06);
      background:rgba(10,10,10,.5);
      cursor:pointer;
      user-select:none;
    }
    .pickRow:hover{filter:brightness(1.10); border-color: rgba(255,122,24,.25)}
    .pickRow .score{color:var(--orange);font-weight:990}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <div class="title">Know It All?</div>
          <div class="small muted">Player Screen</div>
        </div>
      </div>
      <span class="pill">Room: <b id="roomCode">‚Äî</b></span>
    </div>

    <div class="card" id="joinCard">
      <h2 style="margin:6px 0 8px">Join Game</h2>

      <div class="muted small">Enter a nickname, then join the room.</div>
      <div class="divider"></div>

      <div class="row">
        <div style="flex:2">
          <label class="small muted">Nickname</label>
          <input id="nick" placeholder="e.g. Jaz, Tom, Mia..." maxlength="16"/>
        </div>
        <div style="flex:1;min-width:150px">
          <label class="small muted">Room code</label>
          <input id="roomInput" placeholder="ABCDE" maxlength="8"/>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button class="btn orange" id="btnJoin">Join Game</button>
      </div>

      <div class="statusBox" id="joinStatus" style="display:none"></div>
    </div>

    <div class="card" id="waitCard" style="display:none">
      <h2 style="margin:6px 0 8px">Waiting for host...</h2>
      <div class="muted small">Players joined:</div>
      <div class="divider"></div>
      <div id="playersMini" class="muted">‚Äî</div>
    </div>

    <div class="card" id="gameCard" style="display:none">
      <div class="row" style="justify-content:space-between;align-items:flex-start">
        <div style="flex:1">
          <div class="muted small">Question</div>
          <div class="qTitle" id="qText">‚Äî</div>
        </div>
        <div style="text-align:right;min-width:140px">
          <div class="muted small">Timer</div>
          <div class="timerBig"><span id="timeLeft">20</span>s</div>
        </div>
      </div>

      <div class="divider"></div>
      <div class="answers" id="answers"></div>

      <!-- prompt above claim/sabotage -->
      <div class="promptBar" id="perkPrompt">MAKE A SELECTION</div>

      <!-- Powers (all buttons restored) -->
      <div class="powerGrid">
        <button class="powerBtn" id="btnClaim">CLAIM +20</button>
        <button class="powerBtn" id="btnSabotage">SABOTAGE</button>
        <button class="powerBtn" id="btnCheat">CHEAT (1)</button>
        <button class="powerBtn" id="btnHelp">HELP (3)</button>
      </div>

      <div class="statusBox" id="statusMsg" style="display:none"></div>
    </div>

    <div class="card" id="finalCard" style="display:none">
      <h2 style="margin:6px 0 8px" id="finalTitle">‚Äî</h2>
      <div class="muted" id="finalSub">‚Äî</div>
    </div>
  </div>

  <button class="rulesBtn" id="btnRules">Rules</button>

  <!-- Rules modal -->
  <div class="modalBack" id="rulesBack">
    <div class="modal">
      <div class="modalTop">
        <h3>Rules & How to Play</h3>
        <button class="btn" id="rulesClose">Close</button>
      </div>
      <div class="note" style="font-size:13px;line-height:1.55;color:#e9e9e9">
        <b>Know It All?</b> is a fast-paced live quiz for up to <b>20 players</b> per room.<br><br>

        <b>How it works</b><br>
        ‚Ä¢ Join with a nickname and wait for the host.<br>
        ‚Ä¢ Each question is <b>20 seconds</b>. Tap one answer (it locks).<br>
        ‚Ä¢ Host reveals the correct answer and a leaderboard popup appears.<br><br>

        <b>Points</b><br>
        ‚Ä¢ Up to <b>100 points</b> per question based on speed.<br><br>

        <b>Streak Perk</b><br>
        ‚Ä¢ Every 5 correct in a row unlocks a perk: <b>Claim +20</b> or <b>Sabotage</b>.<br>
        ‚Ä¢ Sabotage stops the victim answering the <b>next question</b>.<br>
        ‚Ä¢ The game pauses until all perk players choose.<br><br>

        <b>Powers</b><br>
        ‚Ä¢ <b>CHEAT</b> (once per game): selects correct answer instantly.<br>
        ‚Ä¢ <b>HELP</b> (3 uses): removes 2 wrong answers immediately.
      </div>
    </div>
  </div>

  <!-- Leaderboard modal -->
  <div class="modalBack" id="lbBack">
    <div class="modal">
      <div class="modalTop">
        <h3>Leaderboard</h3>
        <button class="btn" id="lbClose">Close</button>
      </div>
      <div class="lbList" id="lbList"></div>
      <div class="note" id="lbNote">Auto closes in 3 seconds.</div>
    </div>
  </div>

  <!-- Sabotage pick modal -->
  <div class="modalBack" id="pickBack">
    <div class="modal">
      <div class="modalTop">
        <h3>Pick a player to sabotage</h3>
        <button class="btn" id="pickClose">Close</button>
      </div>
      <div class="note">They won‚Äôt be able to answer the next question.</div>
      <div class="lbList" id="pickList"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot,
      collection, query, orderBy, getDocs, serverTimestamp,
      runTransaction
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyClio_l3dpOesNw6tHNLDINOjWNDea0hSk",
      authDomain: "knowitall-a47a1.firebaseapp.com",
      projectId: "knowitall-a47a1",
      storageBucket: "knowitall-a47a1.firebasestorage.app",
      messagingSenderId: "975815651315",
      appId: "1:975815651315:web:7a5e981548448b382aec86"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ---------- Sound (no background music) ----------
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    function ctx(){ if(!audioCtx) audioCtx = new AudioCtx(); return audioCtx; }
    function beep(freq=440, dur=0.06, type="sine", vol=0.08){
      const c = ctx();
      const o = c.createOscillator();
      const g = c.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(c.destination);
      o.start();
      o.stop(c.currentTime + dur);
    }
    function sClick(){ beep(560, 0.03, "square", 0.04); }
    function sReveal(){ beep(740, 0.06, "sawtooth", 0.06); setTimeout(()=>beep(980,0.08,"sawtooth",0.06), 70); }
    function sTick(left){
      // higher pitch nearer to 0
      const freq = 220 + (20-left) * 45;
      beep(freq, 0.03, "sine", 0.03);
    }

    // ---------- RNG ----------
    function mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    function seededShuffle(arr, seed){
      const r = mulberry32(seed);
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(r()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }

    // ---------- Bank ----------
    let BANK=null;
    async function loadBank(){
      if(BANK) return BANK;
      const files = [
        "./question_bank_part1.json",
        "./question_bank_part2.json",
        "./question_bank_part3.json",
        "./question_bank_part4.json"
      ];
      const parts=[];
      for(const f of files){
        const res = await fetch(f, { cache:"no-store" });
        if(!res.ok) throw new Error("Missing file: " + f);
        parts.push(await res.json());
      }
      BANK = parts.flat();
      return BANK;
    }

    function isMathQuestion(q){
      const cat = String(q.category||"").toLowerCase();
      if(cat === "math" || cat === "maths") return true;
      const t = String(q.text||"").toLowerCase();
      const hasDigits = /\d/.test(t);
      const hasOps = /[+\-*/=]|√ó|√∑|\bplus\b|\bminus\b|\btimes\b|\bdivid(ed|e)\b|\bsolve\b|\bcalculate\b/.test(t);
      const looksLikeEquation = /(\d+\s*[+\-*/√ó√∑]\s*\d+)/.test(t);
      return (hasDigits && (hasOps || looksLikeEquation));
    }

    function buildQuestionSet(bank, total, seed){
      const mathsCap = Math.floor(total / 5);
      const maths = [];
      const non = [];
      for(const q of bank){
        (isMathQuestion(q) ? maths : non).push(q);
      }
      const m = seededShuffle(maths, seed + 11).slice(0, mathsCap);
      const n = seededShuffle(non, seed + 22).slice(0, total - m.length);
      return seededShuffle([...m, ...n], seed + 33);
    }

    function isNumericAnswer(ans){
      const s = String(ans).trim();
      return /^-?\d+(\.\d+)?$/.test(s);
    }

    function buildChoices(question, bank, seed, qIndex){
      const r = mulberry32(seed + qIndex * 1000 + 77);
      const correct = String(question.answer).trim();
      const wantNumber = isNumericAnswer(correct);

      let pool = bank
        .map(q => String(q.answer).trim())
        .filter(a => a && a !== correct)
        .filter(a => isNumericAnswer(a) === wantNumber);

      pool = Array.from(new Set(pool));
      const choices = [correct];

      while(choices.length < 4){
        if(pool.length){
          const idx = Math.floor(r() * pool.length);
          const pick = pool.splice(idx,1)[0];
          if(!choices.includes(pick)) choices.push(pick);
        } else {
          if(wantNumber){
            const n = Number(correct);
            const delta = (Math.floor(r()*9)+1) * (r() < 0.5 ? -1 : 1);
            const gen = String(Number.isFinite(n) ? (n + delta) : (Math.floor(r()*200)+1));
            if(!choices.includes(gen)) choices.push(gen);
          } else {
            const gen = "None of the above";
            if(!choices.includes(gen)) choices.push(gen);
          }
        }
      }
      return seededShuffle(choices, seed + qIndex * 17 + 123);
    }

    // ---------- UI ----------
    const joinCard = document.getElementById("joinCard");
    const waitCard = document.getElementById("waitCard");
    const gameCard = document.getElementById("gameCard");
    const finalCard = document.getElementById("finalCard");

    const roomCodeEl = document.getElementById("roomCode");
    const nickEl = document.getElementById("nick");
    const roomInputEl = document.getElementById("roomInput");
    const btnJoin = document.getElementById("btnJoin");
    const joinStatus = document.getElementById("joinStatus");

    const playersMini = document.getElementById("playersMini");
    const qTextEl = document.getElementById("qText");
    const answersEl = document.getElementById("answers");
    const timeLeftEl = document.getElementById("timeLeft");

    const statusMsg = document.getElementById("statusMsg");
    const perkPrompt = document.getElementById("perkPrompt");

    const btnClaim = document.getElementById("btnClaim");
    const btnSabotage = document.getElementById("btnSabotage");
    const btnCheat = document.getElementById("btnCheat");
    const btnHelp = document.getElementById("btnHelp");

    const finalTitle = document.getElementById("finalTitle");
    const finalSub = document.getElementById("finalSub");

    // Rules modal
    const rulesBack = document.getElementById("rulesBack");
    document.getElementById("btnRules").onclick = ()=>{ sClick(); rulesBack.style.display="flex"; };
    document.getElementById("rulesClose").onclick = ()=>{ sClick(); rulesBack.style.display="none"; };

    // Leaderboard modal
    const lbBack = document.getElementById("lbBack");
    const lbList = document.getElementById("lbList");
    const lbNote = document.getElementById("lbNote");
    document.getElementById("lbClose").onclick = ()=>{ sClick(); hideLeaderboard(); };

    // Sabotage pick modal
    const pickBack = document.getElementById("pickBack");
    const pickList = document.getElementById("pickList");
    document.getElementById("pickClose").onclick = ()=>{ sClick(); pickBack.style.display="none"; };

    function show(screen){
      joinCard.style.display = (screen==="join") ? "" : "none";
      waitCard.style.display = (screen==="wait") ? "" : "none";
      gameCard.style.display = (screen==="game") ? "" : "none";
      finalCard.style.display = (screen==="final") ? "" : "none";
    }
    show("join");

    function qs(name){ return new URLSearchParams(location.search).get(name); }

    let roomCode = (qs("room")||"").toUpperCase();
    if(roomCode){
      roomInputEl.value = roomCode;
      roomCodeEl.textContent = roomCode;
    }

    let playerId = localStorage.getItem("kia_playerId") || null;
    function uuid(){ return "p_" + Math.random().toString(16).slice(2) + Date.now().toString(16); }
    function safeNick(n){
      n = String(n||"").trim().replace(/\s+/g," ");
      if(n.length < 2) return null;
      return n.slice(0,16);
    }

    let roomRef=null, playerRef=null, playersCol=null;
    let tickTimer=null;
    let lastQIndex = null;
    let lockedChoice = null;

    let lastTickSecond = null;
    let currentRoom = null;
    let currentMe = null;
    let currentPlayers = [];
    let currentQ = null;
    let currentChoices = [];

    let lbAutoTimer = null;

    function setBtnState(btn, on, disabledText=null){
      btn.classList.toggle("on", !!on);
      btn.classList.toggle("disabled", !on);
      btn.disabled = !on;
      if(disabledText) btn.title = on ? "" : disabledText;
    }

    function setStatus(text, kind="orange"){
      statusMsg.style.display = "";
      statusMsg.className = "statusBox " + kind;
      statusMsg.textContent = text;
    }
    function clearStatus(){ statusMsg.style.display="none"; statusMsg.textContent=""; }

    function showLeaderboard(players){
      lbList.innerHTML = "";
      const sorted = players.slice().sort((a,b)=>(b.score||0)-(a.score||0));
      sorted.forEach((p, i)=>{
        const row = document.createElement("div");
        row.className="lbRow";
        const left = document.createElement("div");
        left.innerHTML = `<div>#${i+1} ${escapeHtml(p.nick||"Player")}</div><div class="mini">Streak: ${p.streak||0}</div>`;
        const right = document.createElement("div");
        right.className="score";
        right.textContent = String(p.score||0);
        row.appendChild(left); row.appendChild(right);
        lbList.appendChild(row);
      });
      lbBack.style.display = "flex";
      lbNote.textContent = "Auto closes in 3 seconds. (Use Close if needed.)";

      if(lbAutoTimer) clearTimeout(lbAutoTimer);
      lbAutoTimer = setTimeout(()=>hideLeaderboard(), 3000);
    }
    function hideLeaderboard(){
      if(lbAutoTimer) clearTimeout(lbAutoTimer);
      lbBack.style.display = "none";
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    async function joinGame(){
      const nick = safeNick(nickEl.value);
      const code = String(roomInputEl.value||"").trim().toUpperCase();
      if(!nick){
        joinStatus.style.display="";
        joinStatus.className="statusBox bad";
        joinStatus.textContent="Enter a nickname (2+ chars).";
        return;
      }
      if(!code){
        joinStatus.style.display="";
        joinStatus.className="statusBox bad";
        joinStatus.textContent="Enter a room code.";
        return;
      }

      roomCode = code;
      roomCodeEl.textContent = roomCode;

      roomRef = doc(db, "rooms", roomCode);
      playersCol = collection(db, "rooms", roomCode, "players");

      const snap = await getDoc(roomRef);
      if(!snap.exists()){
        joinStatus.style.display="";
        joinStatus.className="statusBox bad";
        joinStatus.textContent="Room not found.";
        return;
      }

      if(!playerId){
        playerId = uuid();
        localStorage.setItem("kia_playerId", playerId);
      }
      playerRef = doc(db, "rooms", roomCode, "players", playerId);

      await setDoc(playerRef, {
        nick,
        joinedAt: serverTimestamp(),
        score: 0,
        streak: 0,
        lastAnswer: null,
        lastAnswerMs: null,
        lastCorrect: null,
        cheatUsed: false,
        helpUsed: 0,
        helpMasks: {},
        pendingPerk: false,
        sabotagedNext: false,
        sabotageMsg: null
      }, { merge:true });

      joinStatus.style.display="none";
      bindListeners();
      show("wait");
    }

    btnJoin.onclick = async ()=>{
      try{
        sClick();
        btnJoin.disabled = true;
        await joinGame();
      } finally {
        btnJoin.disabled = false;
      }
    };

    async function getOrder(room){
      const bank = await loadBank();
      return buildQuestionSet(bank, room.questionCount || 50, room.seed);
    }

    function syncTimer(room){
      if(tickTimer) clearInterval(tickTimer);

      lastTickSecond = null;

      if(room.status === "question" && room.qStartMs){
        tickTimer = setInterval(()=>{
          const left = Math.max(0, Math.ceil((room.qStartMs + 20000 - Date.now())/1000));
          timeLeftEl.textContent = String(left);

          if(left !== lastTickSecond){
            // start ticking immediately from 20
            sTick(left);
            lastTickSecond = left;
          }
        }, 120);
      } else {
        timeLeftEl.textContent = "20";
      }
    }

    function renderAnswers(room, me, q, choices){
      answersEl.innerHTML = "";

      const inQuestion = room.status === "question";
      const correct = String(q.answer).trim();

      // lock choice once set
      lockedChoice = me.lastAnswer ?? lockedChoice;

      // sabotage blocks answers this question
      const sabotaged = !!me.sabotagedNext;

      choices.forEach(choice=>{
        const btn = document.createElement("button");
        btn.className="ans";
        btn.textContent = choice;

        // selected highlight (white look)
        if(lockedChoice && String(lockedChoice).trim() === String(choice).trim()){
          btn.classList.add("selected");
        }

        // help mask: immediately show two wrong answers as red/disabled
        const masks = me.helpMasks || {};
        const maskForThis = masks[String(room.qIndex||0)] || [];
        if(maskForThis.includes(String(choice))){
          btn.classList.add("wrongNow");
          btn.classList.add("disabled");
          btn.disabled = true;
        }

        // reveal UI
        if(room.status === "reveal" || room.status === "awaitingPerks"){
          if(String(choice).trim() === correct) btn.classList.add("correctNow");
          else btn.classList.add("wrongNow");
          btn.disabled = true;
        }

        // in-question clicking
        if(!inQuestion || sabotaged){
          btn.classList.add("disabled");
          btn.disabled = true;
        }

        btn.onclick = async ()=>{
          if(!inQuestion) return;
          if(sabotaged) return;
          if(lockedChoice) return; // cannot change once chosen
          sClick();

          lockedChoice = choice;
          await updateDoc(playerRef, { lastAnswer: choice, lastAnswerMs: Date.now() });
          // re-render for selection highlight
          renderAnswers(room, { ...me, lastAnswer: choice }, q, choices);
        };

        answersEl.appendChild(btn);
      });
    }

    function updatePowersUI(room, me){
      const pending = !!me.pendingPerk;

      // prompt bar and claim/sabotage
      perkPrompt.style.display = pending ? "" : "none";
      setBtnState(btnClaim, pending, "Unlock by getting 5 correct in a row");
      setBtnState(btnSabotage, pending, "Unlock by getting 5 correct in a row");

      // CHEAT once per game
      const cheatOk = !me.cheatUsed && room.status === "question" && !me.sabotagedNext && !me.lastAnswer;
      setBtnState(btnCheat, cheatOk, "Used already (1 per game)");

      // HELP up to 3 per game
      const helpOk = (me.helpUsed||0) < 3 && room.status === "question" && !me.sabotagedNext;
      setBtnState(btnHelp, helpOk, "No helps left (3 per game)");
    }

    async function applyHelp(room, me){
      if(!currentQ) return;
      if(room.status !== "question") return;

      const qIndex = room.qIndex || 0;
      const correct = String(currentQ.answer).trim();

      // pick 2 wrong answers to eliminate deterministically
      const wrongs = currentChoices.filter(c => String(c).trim() !== correct);
      const r = mulberry32((room.seed + 555) + qIndex * 999 + hashString(playerId));
      const shuffled = wrongs.slice();
      for(let i=shuffled.length-1;i>0;i--){
        const j = Math.floor(r()*(i+1));
        [shuffled[i],shuffled[j]]=[shuffled[j],shuffled[i]];
      }
      const elim = shuffled.slice(0,2).map(String);

      const newMasks = { ...(me.helpMasks||{}) };
      newMasks[String(qIndex)] = elim;

      await updateDoc(playerRef, {
        helpUsed: (me.helpUsed||0) + 1,
        helpMasks: newMasks
      });

      setStatus("HELP used ‚Äî two wrong answers removed.", "orange");
      setTimeout(clearStatus, 1400);
    }

    function hashString(s){
      let h = 0;
      for(let i=0;i<s.length;i++) h = Math.imul(31,h) + s.charCodeAt(i) | 0;
      return Math.abs(h);
    }

    async function applyCheat(room, me){
      if(!currentQ) return;
      if(room.status !== "question") return;
      if(me.cheatUsed) return;
      if(me.sabotagedNext) return;
      if(me.lastAnswer) return;

      const correct = String(currentQ.answer).trim();
      await updateDoc(playerRef, {
        cheatUsed: true,
        lastAnswer: correct,
        lastAnswerMs: Date.now()
      });

      setStatus("CHEAT used ‚Äî answer locked in.", "orange");
      setTimeout(clearStatus, 1400);
    }

    async function claimPerk(room, me){
      if(!me.pendingPerk) return;

      // +20 points, clear pendingPerk, remove from awaiting list transactionally
      await runTransaction(db, async (tx)=>{
        const roomSnap = await tx.get(roomRef);
        const meSnap = await tx.get(playerRef);
        if(!roomSnap.exists() || !meSnap.exists()) return;

        const r = roomSnap.data();
        const p = meSnap.data();

        if(!p.pendingPerk) return;

        tx.update(playerRef, {
          score: (p.score||0) + 20,
          pendingPerk: false
        });

        const awaiting = Array.isArray(r.awaitingPerkFor) ? r.awaitingPerkFor.slice() : [];
        const idx = awaiting.indexOf(playerId);
        if(idx >= 0) awaiting.splice(idx,1);

        tx.update(roomRef, {
          awaitingPerkFor: awaiting,
          status: awaiting.length ? "awaitingPerks" : "reveal"
        });
      });

      setStatus("Claimed +20 points!", "good");
      setTimeout(clearStatus, 1500);
    }

    function openSabotagePicker(me){
      pickList.innerHTML = "";
      // show players sorted by score
      const sorted = currentPlayers.slice().sort((a,b)=>(b.score||0)-(a.score||0));
      sorted.forEach(p=>{
        // cannot pick self
        if(p.id === playerId) return;

        const row = document.createElement("div");
        row.className = "pickRow";
        row.innerHTML = `<div>
            <div style="font-weight:990">${escapeHtml(p.nick||"Player")}</div>
            <div class="small muted">Score: ${p.score||0}</div>
          </div>
          <div class="score">${p.score||0}</div>`;
        row.onclick = async ()=>{
          sClick();
          await sabotagePlayer(me, p.id, p.nick||"Player");
          pickBack.style.display = "none";
        };
        pickList.appendChild(row);
      });

      pickBack.style.display = "flex";
    }

    async function sabotagePlayer(me, victimId, victimNick){
      if(!me.pendingPerk) return;

      await runTransaction(db, async (tx)=>{
        const roomSnap = await tx.get(roomRef);
        const meSnap = await tx.get(playerRef);
        const victimRef = doc(db, "rooms", roomCode, "players", victimId);
        const vSnap = await tx.get(victimRef);

        if(!roomSnap.exists() || !meSnap.exists() || !vSnap.exists()) return;

        const r = roomSnap.data();
        const p = meSnap.data();
        const v = vSnap.data();

        if(!p.pendingPerk) return;

        // apply sabotage to victim for NEXT question
        tx.update(victimRef, {
          sabotagedNext: true,
          sabotageMsg: `You have been sabotaged by ${p.nick || "a player"} ‚Äî you cannot answer the next question.`
        });

        // clear perk and remove from awaiting
        tx.update(playerRef, { pendingPerk:false });

        const awaiting = Array.isArray(r.awaitingPerkFor) ? r.awaitingPerkFor.slice() : [];
        const idx = awaiting.indexOf(playerId);
        if(idx >= 0) awaiting.splice(idx,1);

        tx.update(roomRef, {
          awaitingPerkFor: awaiting,
          status: awaiting.length ? "awaitingPerks" : "reveal",
          sabotage: { victimId, byId: playerId, byNick: p.nick || "Player", qIndex: r.qIndex ?? null }
        });
      });

      setStatus(`Sabotaged ${victimNick}!`, "good");
      setTimeout(clearStatus, 1600);
    }

    btnHelp.onclick = async ()=>{
      if(!currentRoom || !currentMe) return;
      if(btnHelp.disabled) return;
      sClick();
      await applyHelp(currentRoom, currentMe);
    };

    btnCheat.onclick = async ()=>{
      if(!currentRoom || !currentMe) return;
      if(btnCheat.disabled) return;
      sClick();
      await applyCheat(currentRoom, currentMe);
    };

    btnClaim.onclick = async ()=>{
      if(!currentRoom || !currentMe) return;
      if(btnClaim.disabled) return;
      sClick();
      await claimPerk(currentRoom, currentMe);
    };

    btnSabotage.onclick = async ()=>{
      if(!currentRoom || !currentMe) return;
      if(btnSabotage.disabled) return;
      sClick();
      openSabotagePicker(currentMe);
    };

    function renderFinal(room, me){
      // determine winner(s)
      const sorted = currentPlayers.slice().sort((a,b)=>(b.score||0)-(a.score||0));
      const top = sorted[0]?.score || 0;
      const winners = sorted.filter(p=>(p.score||0)===top).map(p=>p.nick);
      const iWin = winners.includes(me.nick);

      finalTitle.textContent = iWin ? "You Know It All! üéâ" : "Not too bad! üôÇ";
      finalSub.textContent = iWin ? "You finished top!" : "Good effort ‚Äî try again!";
    }

    function bindListeners(){
      onSnapshot(roomRef, async (snap)=>{
        if(!snap.exists()){ show("join"); return; }
        const room = snap.data();
        currentRoom = room;

        const meSnap = await getDoc(playerRef);
        if(!meSnap.exists()) return;
        const me = meSnap.data();
        currentMe = me;

        // players list (also used for leaderboard popup and sabotage picker)
        const pSnap = await getDocs(query(playersCol, orderBy("score","desc")));
        currentPlayers = pSnap.docs.map(d=>({ id:d.id, ...d.data() }));

        if(room.status === "lobby"){
          show("wait");
          // list players joined in wait screen
          const byJoin = currentPlayers.slice().sort((a,b)=>{
            const aT = a.joinedAt?.seconds || 0;
            const bT = b.joinedAt?.seconds || 0;
            return aT - bT;
          });
          playersMini.textContent = byJoin.length ? byJoin.map(p=>p.nick).join(", ") : "No other players yet.";
          return;
        }

        if(room.status === "final"){
          show("final");
          renderFinal(room, me);
          return;
        }

        // question/reveal/awaitingPerks
        show("game");

        const order = await getOrder(room);
        const qIndex = room.qIndex || 0;

        // detect new question -> clear selection lock + clear status
        if(lastQIndex !== qIndex){
          lastQIndex = qIndex;
          lockedChoice = me.lastAnswer; // should be null at start of question
          clearStatus();
        }

        currentQ = order[qIndex];
        qTextEl.textContent = currentQ?.text || "Question missing";

        currentChoices = buildChoices(currentQ, order, room.seed, qIndex);
        renderAnswers(room, me, currentQ, currentChoices);
        syncTimer(room);
        updatePowersUI(room, me);

        // show sabotage message if present
        if(me.sabotageMsg){
          setStatus(me.sabotageMsg, "bad");
          // clear it so it doesn't spam
          await updateDoc(playerRef, { sabotageMsg: null });
        }

        // On reveal or awaitingPerks: show result + leaderboard popup
        if(room.status === "reveal" || room.status === "awaitingPerks"){
          sReveal();

          // result line
          const got = me.lastCorrect === true;
          if(got) setStatus("Correct ‚úÖ", "good");
          else if(me.lastCorrect === false) setStatus("Incorrect ‚ùå", "bad");

          // show leaderboard popup, but it auto-closes after 3 seconds
          // If player needs to pick a perk, we still auto-close so they can choose.
          showLeaderboard(currentPlayers);
        } else {
          // if question screen, do not show leaderboard modal
          // (but allow manual closing if it was open)
        }

        // If pending perk, ensure leaderboard doesn't block selection
        // (auto close timer will handle, but we also nudge close if still open after 3s)
        if(me.pendingPerk){
          // the prompt bar + claim/sabotage is already shown by updatePowersUI
          // ensure leaderboard will disappear soon
        }
      });
    }
  </script>
</body>
</html>
