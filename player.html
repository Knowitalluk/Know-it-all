<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Know It All? — Player</title>

  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

  <style>
    :root{
      --bg0:#050506; --bg1:#0b0b10; --line: rgba(255,255,255,.10);
      --text:#f5f7ff; --muted: rgba(245,247,255,.70);
      --orange:#ff6a00; --orange2:#ff9a3d; --glow: rgba(255,106,0,.35);
      --good:#2cff9a; --bad:#ff3b5c; --radius:18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(255,106,0,.14), transparent 60%),
        radial-gradient(900px 500px at 80% 20%, rgba(255,154,61,.10), transparent 60%),
        radial-gradient(1200px 700px at 60% 90%, rgba(255,106,0,.08), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      min-height:100vh;
    }
    .container{ max-width:900px; margin:0 auto; padding:22px; }
    .brand h1{ margin:0; font-weight:1000; font-size:36px; letter-spacing:.5px; }
    .brand h1 span{ color:var(--orange); text-shadow:0 0 20px var(--glow); }
    .tag{ color:var(--muted); font-size:13px; letter-spacing:.18em; text-transform:uppercase; margin-top:6px; }

    .card{
      background: linear-gradient(180deg, rgba(15,17,23,.92), rgba(10,12,16,.92));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:16px;
      box-shadow: 0 15px 60px rgba(0,0,0,.45), 0 0 0 1px rgba(255,106,0,.06) inset;
      backdrop-filter: blur(10px);
      margin-top: 14px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px; border-radius:999px;
      border:1px solid rgba(255,106,0,.35);
      background: rgba(255,106,0,.10);
      color: var(--orange2);
      box-shadow: 0 0 22px rgba(255,106,0,.12);
      font-weight:1000; letter-spacing:.04em;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .small{ color:var(--muted); font-size:13px; }

    input, button{
      font:inherit; border-radius:14px; padding:12px 12px; outline:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: var(--text);
    }
    input::placeholder{ color: rgba(245,247,255,.45); }
    button{
      cursor:pointer; font-weight:1000;
      border-color: rgba(255,106,0,.55);
      background: linear-gradient(180deg, rgba(255,106,0,.35), rgba(255,106,0,.12));
      box-shadow: 0 10px 30px rgba(255,106,0,.10);
    }
    button:disabled{ opacity:.35; cursor:not-allowed; }

    .btn-ghost{
      border-color: rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      box-shadow:none;
      font-weight:900;
    }
    .btn-cheat{
      border-color: rgba(255,59,92,.45);
      background: linear-gradient(180deg, rgba(255,59,92,.18), rgba(255,59,92,.06));
    }

    .qtext{ font-size:30px; font-weight:1000; margin:10px 0 6px; }
    .answers{ display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px; margin-top:10px; }
    @media (max-width:520px){ .answers{ grid-template-columns:1fr; } }

    .answer{
      text-align:left; padding:14px; border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      cursor:pointer;
      transition: transform .08s ease, border-color .08s ease, background .08s ease, box-shadow .08s ease;
    }
    .answer:active{ transform: scale(.99); }
    .answer.locked{ opacity:.55; cursor:not-allowed; }
    .answer.selected{
      border-color: rgba(255,255,255,.85);
      background: rgba(255,255,255,.14);
      box-shadow: 0 0 0 1px rgba(255,255,255,.22) inset, 0 10px 30px rgba(0,0,0,.25);
    }
    .answer.removed{
      border-color: rgba(255,59,92,.70);
      background: rgba(255,59,92,.14);
      opacity:.55;
      cursor:not-allowed;
    }

    .toast{
      margin-top:10px; padding:10px 12px; border-radius:14px;
      border:1px solid rgba(255,106,0,.25);
      background: rgba(255,106,0,.08);
      color: var(--orange2);
    }
    .toast.good{
      border-color: rgba(44,255,154,.35);
      background: rgba(44,255,154,.10);
      color: rgba(220,255,240,.95);
    }
    .toast.bad{
      border-color: rgba(255,59,92,.28);
      background: rgba(255,59,92,.10);
      color: rgba(255,220,228,.92);
    }
    .toast.prompt{
      border-color: rgba(255,106,0,.85);
      background: rgba(255,106,0,.20);
      color: rgba(255,240,228,.98);
      box-shadow: 0 0 0 1px rgba(255,106,0,.14) inset, 0 20px 50px rgba(255,106,0,.10);
      font-weight:1000;
      letter-spacing:.03em;
      text-align:center;
    }

    .powerRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    .powerRow button{ flex:1; min-width:160px; }

    .kpi{ display:flex; gap:10px; flex-wrap:wrap; margin-top: 8px; }
    .kpi .pill{
      padding: 10px 12px; border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      min-width: 150px;
    }
    .kpi .pill strong{ color: var(--text); display:block; }

    /* floating rules btn */
    .rulesBtn{
      position:fixed;
      right:14px;
      bottom:14px;
      z-index:9998;
      border-radius:999px;
      padding:10px 14px;
      border:1px solid rgba(255,106,0,.55);
      background: rgba(255,106,0,.14);
      box-shadow: 0 10px 30px rgba(255,106,0,.12);
      font-weight:1000;
    }

    /* MODALS */
    .modal{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
      background: rgba(0,0,0,.68);
      backdrop-filter: blur(8px);
      z-index: 9999;
    }
    .modal.on{ display:flex; }
    .modalCard{
      width:min(720px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(15,17,23,.96), rgba(10,12,16,.96));
      box-shadow: 0 20px 80px rgba(0,0,0,.55), 0 0 0 1px rgba(255,106,0,.06) inset;
      padding: 16px;
    }
    .modalTop{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-bottom: 10px;
    }
    .modalTitle{
      font-size: 20px;
      font-weight: 1000;
      letter-spacing: .02em;
    }
    .lb{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      overflow:hidden;
      background: rgba(255,255,255,.03);
    }
    .lbRow{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.07);
      color: var(--muted);
    }
    .lbRow:last-child{ border-bottom:0; }
    .lbRow strong{ color: var(--text); }
    .targetBtn{
      width:100%;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      box-shadow:none;
      padding: 12px 12px;
      margin-top: 10px;
      text-align:left;
    }
    .targetBtn:hover{ filter:brightness(1.12); }

    .rulesText{
      color: rgba(245,247,255,.90);
      line-height: 1.5;
    }
    .rulesText h3{
      margin: 14px 0 6px;
      font-size: 16px;
      letter-spacing: .02em;
      color: var(--orange2);
    }
    .rulesText ul{ margin: 8px 0 0 18px; padding:0; }
    .rulesText li{ margin: 6px 0; color: rgba(245,247,255,.86); }
  </style>
</head>
<body>
  <button class="rulesBtn" id="btnRules">Rules</button>

  <div class="container">
    <div class="brand">
      <h1>Know It <span>All?</span></h1>
      <div class="tag">PLAYER MODE • JOIN VIA QR</div>
    </div>

    <div class="card" id="joinCard">
      <div class="badge">Join Game</div>
      <p class="small">Enter nickname. Room code is auto-filled from the QR link.</p>
      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
        <input id="roomInput" class="mono" placeholder="ROOM CODE" style="flex:1; min-width:180px;" />
        <input id="nameInput" placeholder="Nickname" style="flex:1; min-width:160px;" />
        <button id="btnJoin">Join</button>
      </div>
      <div class="toast" id="joinToast" style="display:none;"></div>
    </div>

    <div class="card" id="waitCard" style="display:none;">
      <div class="badge">Waiting for Host…</div>
      <div class="qtext">Get Ready ⚡</div>
      <p class="small">The host will start the game soon.</p>
      <div class="kpi">
        <div class="pill"><strong>Status</strong><span class="mono" id="status">-</span></div>
        <div class="pill"><strong>Your Score</strong><span class="mono" id="score">0</span></div>
        <div class="pill"><strong>Your Streak</strong><span class="mono" id="streak">0</span></div>
      </div>
      <div class="toast bad" id="blockedToast" style="display:none;"></div>
    </div>

    <div class="card" id="playCard" style="display:none;">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div class="badge" id="phaseBadge">Question</div>
        <div class="badge">Timer: <span class="mono" id="timer">20</span>s</div>
      </div>

      <div class="qtext" id="qText">Question</div>
      <div class="answers" id="answers"></div>

      <div class="toast prompt" id="selectionPrompt" style="display:none;">MAKE A SELECTION</div>

      <div class="powerRow">
        <button id="btnClaim" disabled>Claim +20</button>
        <button id="btnSabotage" disabled>Sabotage</button>
      </div>

      <div class="powerRow">
        <button id="btnCheat" class="btn-cheat" disabled>CHEAT (1)</button>
        <button id="btnHelp" disabled>HELP (3)</button>
      </div>

      <div class="toast" id="playToast" style="display:none;"></div>
    </div>

    <div class="card" id="finalCard" style="display:none;">
      <div class="badge">Final</div>
      <div style="font-size:44px; font-weight:1000; text-align:center; margin:12px 0;" id="finalTitle">You Know It All</div>
      <div style="text-align:center; letter-spacing:6px; color:var(--orange2);" id="finalSpark">✦ ✧ ✦ ✧ ✦</div>
      <p class="small" id="finalSub" style="text-align:center; margin-top:12px;"></p>
    </div>
  </div>

  <!-- Reveal Modal -->
  <div class="modal" id="revealModal">
    <div class="modalCard">
      <div class="modalTop">
        <div class="modalTitle">Reveal • Leaderboard</div>
        <button class="btn-ghost" id="btnCloseReveal">Close</button>
      </div>

      <div class="toast" id="revealResultToast" style="display:none;"></div>
      <div class="lb" id="revealLB"></div>

      <div class="small" style="margin-top:10px; opacity:.85;" id="revealHint">
        Host will start the next question…
      </div>
    </div>
  </div>

  <!-- Sabotage Modal -->
  <div class="modal" id="sabotageModal">
    <div class="modalCard">
      <div class="modalTop">
        <div class="modalTitle">Sabotage • Choose a player</div>
        <button class="btn-ghost" id="btnCloseSab">Close</button>
      </div>
      <div class="small">Tap a player to block them from answering the <b>next</b> question.</div>
      <div id="sabTargets"></div>
    </div>
  </div>

  <!-- Rules Modal -->
  <div class="modal" id="rulesModal">
    <div class="modalCard">
      <div class="modalTop">
        <div class="modalTitle">Rules • How to Play</div>
        <button class="btn-ghost" id="btnCloseRules">Close</button>
      </div>
      <div class="rulesText" id="rulesContent"></div>
    </div>
  </div>

  <script>
    /************** SOUNDS (WebAudio) **************/
    const SFX = (() => {
      let ctx = null;
      function getCtx(){
        if(!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
        return ctx;
      }
      function ensureUnlocked(){ try{ getCtx().resume(); }catch{} }

      function tone(freq=440, dur=0.06, type="sine", vol=0.06){
        const c = getCtx();
        const o = c.createOscillator();
        const g = c.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g); g.connect(c.destination);
        o.start();
        o.stop(c.currentTime + dur);
      }
      function click(){ tone(900,0.03,"square",0.04); }

      function reveal(){
        tone(660,0.09,"sine",0.06);
        setTimeout(()=>tone(990,0.10,"sine",0.06), 90);
        setTimeout(()=>tone(1320,0.12,"sine",0.06), 200);
      }

      // Countdown tick: higher pitch as time decreases
      let lastTickSec = null;
      function tick(secLeft){
        if(secLeft === lastTickSec) return;
        lastTickSec = secLeft;
        const s = Math.max(0, Math.min(20, secLeft));
        const freq = 420 + (20 - s) * 40; // 20->420, 0->1220
        tone(freq, 0.03, "square", 0.028);
      }
      function resetTick(){ lastTickSec = null; }

      return { ensureUnlocked, click, reveal, tick, resetTick };
    })();

    /************** FIREBASE **************/
    const firebaseConfig = {
      apiKey: "AIzaSyClio_l3dpOesNw6tHNLDINOjWNDea0hSk",
      authDomain: "knowitall-a47a1.firebaseapp.com",
      projectId: "knowitall-a47a1",
      storageBucket: "knowitall-a47a1.firebasestorage.app",
      messagingSenderId: "975815651315",
      appId: "1:975815651315:web:7a5e981548448b382aec86"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    function nowMs(){ return Date.now(); }
    function fmtTimeLeft(endsAtMs){ return Math.max(0, Math.ceil((endsAtMs - nowMs())/1000)); }
    function $(id){ return document.getElementById(id); }
    function show(el,on=true){ el.style.display = on ? "" : "none"; }
    function setToast(el,msg,cls){
      el.className = "toast" + (cls ? (" " + cls) : "");
      if(!msg){ el.style.display="none"; el.textContent=""; }
      else { el.style.display=""; el.textContent=msg; }
    }
    function qparam(name){ return new URL(location.href).searchParams.get(name); }
    function labelAnswer(i){ return ["A","B","C","D"][i] || String(i+1); }
    function modalOn(id, on){
      const m = $(id);
      if(on) m.classList.add("on");
      else m.classList.remove("on");
    }

    let uid = null;
    let joined = false;
    let roomId = (qparam("room") || "").toUpperCase();

    let unsubRoom = null;
    let unsubPlayers = null;

    let latestRoom = null;
    let latestPlayers = [];

    let timerUI = null;

    const localHelpRemoved = new Map();
    const localSelected = new Map();

    // prevents reveal modal from reopening due to snapshot updates
    let suppressRevealForQ = null;

    // auto close timer for decision players
    let autoCloseTimer = null;

    // play reveal sound once per reveal question
    let lastRevealSoundQ = null;

    function roomRef(){ return db.collection("rooms").doc(roomId); }
    function playersRef(){ return roomRef().collection("players"); }
    function answersRef(){ return roomRef().collection("answers"); }

    async function signInPlayer(){
      const cred = await auth.signInAnonymously();
      uid = cred.user.uid;
    }

    async function joinGame(){
      roomId = ($("roomInput").value || "").trim().toUpperCase();
      const name = ($("nameInput").value || "").trim();
      if(!roomId || !name){
        setToast($("joinToast"), "Enter nickname (and ensure room code is present).");
        return;
      }

      const snap = await roomRef().get();
      if(!snap.exists){
        setToast($("joinToast"), "Room not found. Scan the QR again.");
        return;
      }

      await playersRef().doc(uid).set({
        id: uid,
        name,
        score: 0,
        streak: 0,
        rewardPending: false,
        rewardEarnedAtQuestionIndex: null,
        lastAnswer: null,
        cheatLeft: 1,
        helpLeft: 3,
        joinedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge:true });

      joined = true;
      setToast($("joinToast"), "");
      show($("joinCard"), false);
      show($("waitCard"), true);

      listenLive();
    }

    function keyForRoomQ(room){
      return `${roomId}|${room.questionIndex}`;
    }

    function isSabotaged(room){
      if(room.status !== "question") return false;
      const s = room.sabotage;
      if(!s || s.activeForQuestionIndex !== room.questionIndex) return false;
      const blocks = s.blocks || [];
      return blocks.some(b => b.targetPlayerId === uid);
    }

    function isPendingStreakDecision(room, me){
      if(room.status !== "reveal") return false;
      if(!room.pause || room.pause.type !== "streak") return false;
      const pending = room.pause.pendingPlayerIds || [];
      return !!(me && me.rewardPending === true && pending.includes(uid));
    }

    async function alreadyAnswered(qIdx){
      const doc = await answersRef().doc(`${qIdx}_${uid}`).get();
      return doc.exists;
    }

    async function writeAnswer(qIdx, choiceIndex){
      if(await alreadyAnswered(qIdx)) return;
      await answersRef().doc(`${qIdx}_${uid}`).set({
        id: `${qIdx}_${uid}`,
        uid,
        roomId,
        questionIndex: qIdx,
        choiceIndex,
        answeredAtMs: nowMs()
      });
    }

    async function pickAnswer(choiceIndex){
      if(!latestRoom) return;
      if(latestRoom.status !== "question") return;
      if(isSabotaged(latestRoom)) return;

      const key = keyForRoomQ(latestRoom);
      if(localSelected.has(key)) return; // locked

      localSelected.set(key, choiceIndex);
      renderAnswers();

      await writeAnswer(latestRoom.questionIndex, choiceIndex);
      setToast($("playToast"), "Answer locked in.");
    }

    function suppressReveal(qIdx){
      suppressRevealForQ = qIdx;
      modalOn("revealModal", false);
      $("revealHint").textContent = "Host will start the next question…";
    }

    function clearAutoClose(){
      if(autoCloseTimer){ clearTimeout(autoCloseTimer); autoCloseTimer = null; }
    }

    function startAutoClose(room){
      clearAutoClose();
      $("revealHint").textContent = "You unlocked a 5-streak! Closing in 3 seconds so you can choose…";
      autoCloseTimer = setTimeout(()=>{
        if(latestRoom && latestRoom.status === "reveal" && latestRoom.questionIndex === room.questionIndex){
          suppressReveal(room.questionIndex); // key fix: stops reopen
        }
      }, 3000);
    }

    async function claim20(){
      if(!latestRoom) return;
      const meSnap = await playersRef().doc(uid).get();
      if(!meSnap.exists) return;
      const me = meSnap.data();
      if(!isPendingStreakDecision(latestRoom, me)) return;

      await db.runTransaction(async (tx) => {
        const roomDoc = await tx.get(roomRef());
        const meDoc = await tx.get(playersRef().doc(uid));
        if(!roomDoc.exists || !meDoc.exists) return;

        const room = roomDoc.data();
        const player = meDoc.data();

        const pending = (room.pause?.pendingPlayerIds || []).slice();
        if(!pending.includes(uid)) return;

        const newPending = pending.filter(x => x !== uid);

        tx.update(playersRef().doc(uid), {
          score: (player.score||0) + 20,
          rewardPending: false,
          rewardEarnedAtQuestionIndex: null,
          streak: 0
        });

        tx.update(roomRef(), {
          pause: newPending.length ? { ...room.pause, pendingPlayerIds: newPending } : null,
          updatedAtMs: nowMs()
        });
      });

      modalOn("sabotageModal", false);
      $("selectionPrompt").style.display = "none";
    }

    async function openSabotage(){
      if(!latestRoom) return;
      const meSnap = await playersRef().doc(uid).get();
      if(!meSnap.exists) return;
      const me = meSnap.data();
      if(!isPendingStreakDecision(latestRoom, me)) return;

      if(!latestPlayers || latestPlayers.length === 0){
        const pSnap = await playersRef().get();
        latestPlayers = pSnap.docs.map(d=>({ id:d.id, ...d.data() }));
      }

      renderSabotageTargets();
      modalOn("sabotageModal", true);
    }

    function renderSabotageTargets(){
      const wrap = $("sabTargets");
      wrap.innerHTML = "";

      const candidates = latestPlayers
        .filter(p => p.id !== uid)
        .sort((a,b)=> (b.score - a.score) || (a.name||"").localeCompare(b.name||""));

      if(candidates.length === 0){
        const d = document.createElement("div");
        d.className = "toast bad";
        d.textContent = "No players available to sabotage.";
        wrap.appendChild(d);
        return;
      }

      candidates.forEach((p,i)=>{
        const btn = document.createElement("button");
        btn.className = "targetBtn";
        btn.innerHTML = `<div style="display:flex;justify-content:space-between;gap:10px;">
          <div><span class="mono" style="opacity:.7">#${i+1}</span> <b>${p.name}</b></div>
          <div class="mono">${p.score||0}</div>
        </div>`;
        btn.onclick = () => { SFX.ensureUnlocked(); SFX.click(); applySabotage(p.id); };
        wrap.appendChild(btn);
      });
    }

    async function applySabotage(targetId){
      if(!latestRoom) return;

      await db.runTransaction(async (tx) => {
        const roomDoc = await tx.get(roomRef());
        const meDoc = await tx.get(playersRef().doc(uid));
        if(!roomDoc.exists || !meDoc.exists) return;

        const room = roomDoc.data();
        const me = meDoc.data();

        const pending = (room.pause?.pendingPlayerIds || []).slice();
        if(!pending.includes(uid)) return;

        const newPending = pending.filter(x => x !== uid);

        const nextQ = room.questionIndex + 1;
        let sabotage = room.sabotage;

        if(!sabotage || sabotage.activeForQuestionIndex !== nextQ){
          sabotage = { activeForQuestionIndex: nextQ, blocks: [] };
        }

        const blocks = Array.isArray(sabotage.blocks) ? sabotage.blocks.slice() : [];
        blocks.push({ targetPlayerId: targetId, byName: me.name });

        tx.update(roomRef(), {
          sabotage: { activeForQuestionIndex: nextQ, blocks },
          pause: newPending.length ? { ...room.pause, pendingPlayerIds: newPending } : null,
          updatedAtMs: nowMs()
        });

        tx.update(playersRef().doc(uid), {
          rewardPending: false,
          rewardEarnedAtQuestionIndex: null,
          streak: 0
        });
      });

      modalOn("sabotageModal", false);
      $("selectionPrompt").style.display = "none";
    }

    async function cheat(){
      if(!latestRoom) return;
      if(latestRoom.status !== "question") return;
      if(isSabotaged(latestRoom)) return;

      const meSnap = await playersRef().doc(uid).get();
      if(!meSnap.exists) return;
      const me = meSnap.data();

      const key = keyForRoomQ(latestRoom);
      if(localSelected.has(key)) return;
      if(me.rewardPending) return;
      if((me.cheatLeft||0) <= 0) return;

      await playersRef().doc(uid).update({ cheatLeft: (me.cheatLeft||0) - 1 });

      const correctIndex = latestRoom.currentQuestion.correctIndex;
      localSelected.set(key, correctIndex);
      renderAnswers();

      await writeAnswer(latestRoom.questionIndex, correctIndex);
      setToast($("playToast"), "CHEAT used. Answer locked in.");
    }

    async function help5050(){
      if(!latestRoom) return;
      if(latestRoom.status !== "question") return;
      if(isSabotaged(latestRoom)) return;

      const meSnap = await playersRef().doc(uid).get();
      if(!meSnap.exists) return;
      const me = meSnap.data();

      const key = keyForRoomQ(latestRoom);
      if(localSelected.has(key)) return;
      if(me.rewardPending) return;
      if((me.helpLeft||0) <= 0) return;
      if(localHelpRemoved.has(key)) return;

      const correct = latestRoom.currentQuestion.correctIndex;
      const wrong = [];
      for(let i=0;i<latestRoom.currentQuestion.options.length;i++){
        if(i !== correct) wrong.push(i);
      }
      wrong.sort(()=>Math.random()-0.5);
      localHelpRemoved.set(key, wrong.slice(0,2));

      await playersRef().doc(uid).update({ helpLeft: (me.helpLeft||0) - 1 });

      renderAnswers(); // immediate red-out
      setToast($("playToast"), "HELP used.");
    }

    function renderAnswers(){
      if(!latestRoom) return;

      const ansBox = $("answers");
      ansBox.innerHTML = "";
      const q = latestRoom.currentQuestion;
      if(!q) return;

      const key = keyForRoomQ(latestRoom);
      const removed = localHelpRemoved.get(key) || [];
      const selected = localSelected.get(key);

      const lockAll = latestRoom.status !== "question" || isSabotaged(latestRoom) || localSelected.has(key);

      q.options.forEach((opt, idx)=>{
        const b = document.createElement("button");
        b.className = "answer";

        if(typeof selected === "number" && selected === idx) b.classList.add("selected");
        if(removed.includes(idx)){
          b.classList.add("removed");
          b.disabled = true;
        }

        if(lockAll && !(typeof selected === "number" && selected === idx)){
          b.classList.add("locked");
          b.disabled = true;
        }

        if(!lockAll && !b.disabled){
          b.onclick = () => { SFX.ensureUnlocked(); SFX.click(); pickAnswer(idx); };
        }

        b.innerHTML = `<div class="small mono">${labelAnswer(idx)}</div><div style="font-weight:1000;margin-top:4px;">${opt}</div>`;
        ansBox.appendChild(b);
      });
    }

    function renderRevealLeaderboard(me){
      const box = $("revealLB");
      box.innerHTML = "";

      const sorted = latestPlayers.slice().sort((a,b)=> (b.score - a.score) || (a.name||"").localeCompare(b.name||""));
      sorted.forEach((p,i)=>{
        const row = document.createElement("div");
        row.className = "lbRow";
        row.innerHTML = `<div><span class="mono" style="opacity:.7">#${i+1}</span> <strong>${p.name||"Player"}</strong>${p.id===uid ? ' <span class="badge" style="padding:4px 10px; font-size:12px;">YOU</span>' : ''}</div><div class="mono">${p.score||0}</div>`;
        box.appendChild(row);
      });

      if(latestRoom && latestRoom.status === "reveal" && me && me.lastAnswer && me.lastAnswer.questionIndex === latestRoom.questionIndex){
        if(me.lastAnswer.isCorrect){
          setToast($("revealResultToast"), `✅ Correct! +${me.lastAnswer.pointsAwarded||0} points`, "good");
        }else{
          setToast($("revealResultToast"), `❌ Wrong answer`, "bad");
        }
      }else{
        setToast($("revealResultToast"), "", "");
      }
    }

    function fillRules(){
      $("rulesContent").innerHTML = `
        <h3>Players</h3>
        <ul>
          <li><b>Recommended:</b> 2–20 players per game (best experience).</li>
          <li>One device is the <b>Host</b>. Everyone else joins on their phone.</li>
        </ul>

        <h3>How to play</h3>
        <ul>
          <li>The host starts the game and controls reveal + next question.</li>
          <li>Each question has a <b>20 second</b> timer.</li>
          <li>Tap an answer to lock it in — you <b>cannot change</b> it.</li>
          <li>On reveal, the leaderboard updates for everyone.</li>
        </ul>

        <h3>Scoring</h3>
        <ul>
          <li>Correct answers score based on speed.</li>
          <li>Up to <b>100 points</b> per question.</li>
        </ul>

        <h3>5-Streak Reward</h3>
        <ul>
          <li>Get <b>5 correct in a row</b> to unlock a choice:</li>
          <li><b>Claim +20</b> bonus points, or <b>Sabotage</b> another player.</li>
          <li>The game pauses until all streak players choose.</li>
        </ul>

        <h3>Sabotage</h3>
        <ul>
          <li>Pick a player from the list.</li>
          <li>They cannot answer the <b>next</b> question and get a warning.</li>
        </ul>

        <h3>Power Buttons</h3>
        <ul>
          <li><b>CHEAT (1 use per game):</b> auto-picks the correct answer and locks it.</li>
          <li><b>HELP (3 uses per game):</b> removes 2 wrong answers immediately (red).</li>
        </ul>
      `;
    }

    function listenLive(){
      if(unsubRoom) unsubRoom();
      if(unsubPlayers) unsubPlayers();

      unsubPlayers = playersRef().onSnapshot((snap)=>{
        latestPlayers = snap.docs.map(d=>({ id:d.id, ...d.data() }));
        if(latestRoom && latestRoom.status === "reveal"){
          const me = latestPlayers.find(p=>p.id===uid) || null;
          renderRevealLeaderboard(me);
        }
      }, (err)=>console.error("Players listener error:", err));

      unsubRoom = roomRef().onSnapshot(async (snap)=>{
        if(!snap.exists) return;
        latestRoom = snap.data();

        show($("joinCard"), !joined);
        show($("waitCard"), joined && latestRoom.status === "lobby");
        show($("playCard"), joined && (latestRoom.status === "question" || latestRoom.status === "reveal"));
        show($("finalCard"), joined && latestRoom.status === "final");

        $("status").textContent = latestRoom.status;
        $("phaseBadge").textContent = latestRoom.status === "reveal" ? "Reveal" : "Question";
        $("qText").textContent = latestRoom.currentQuestion?.text || "Question";

        // Timer + ticker sound
        if(timerUI) clearInterval(timerUI);
        if(latestRoom.status === "question" || latestRoom.status === "reveal"){
          timerUI = setInterval(()=>{
            const left = fmtTimeLeft(latestRoom.questionEndsAt);
            $("timer").textContent = String(left);
            if(latestRoom.status === "question") SFX.tick(left);
          }, 150);
        } else {
          SFX.resetTick();
        }

        // sabotage message
        if(joined && isSabotaged(latestRoom)){
          const blocks = latestRoom.sabotage?.blocks || [];
          const hit = blocks.find(b=>b.targetPlayerId === uid);
          setToast($("blockedToast"), `⚠ You have been sabotaged by ${hit?.byName || "a player"}. You cannot answer this question.`, "bad");
        }else{
          setToast($("blockedToast"), "", "bad");
        }

        const meSnap = await playersRef().doc(uid).get();
        const me = meSnap.exists ? meSnap.data() : null;

        if(me){
          $("score").textContent = String(me.score||0);
          $("streak").textContent = String(me.streak||0);
          $("btnCheat").textContent = `CHEAT (${me.cheatLeft||0})`;
          $("btnHelp").textContent = `HELP (${me.helpLeft||0})`;
        }

        const pendingForMe = isPendingStreakDecision(latestRoom, me);
        $("btnClaim").disabled = !pendingForMe;
        $("btnSabotage").disabled = !pendingForMe;
        $("selectionPrompt").style.display = pendingForMe ? "" : "none";

        const key = keyForRoomQ(latestRoom);
        const canAct = latestRoom.status === "question"
          && !isSabotaged(latestRoom)
          && me && !me.rewardPending
          && !localSelected.has(key);

        $("btnCheat").disabled = !(canAct && (me?.cheatLeft||0) > 0);
        $("btnHelp").disabled  = !(canAct && (me?.helpLeft||0) > 0);

        renderAnswers();

        // Reveal modal with suppression fix + reveal sound once
        if(joined && latestRoom.status === "reveal"){
          if(suppressRevealForQ === latestRoom.questionIndex){
            modalOn("revealModal", false);
          }else{
            modalOn("revealModal", true);
          }

          if(!latestPlayers || latestPlayers.length === 0){
            const pSnap = await playersRef().get();
            latestPlayers = pSnap.docs.map(d=>({ id:d.id, ...d.data() }));
          }
          renderRevealLeaderboard(me);

          // Reveal sound once per reveal question (only if not suppressed)
          if(suppressRevealForQ !== latestRoom.questionIndex && lastRevealSoundQ !== latestRoom.questionIndex){
            lastRevealSoundQ = latestRoom.questionIndex;
            // will only play if audio is unlocked by a prior click (browser rule)
            SFX.reveal();
          }

          if(pendingForMe && suppressRevealForQ !== latestRoom.questionIndex){
            startAutoClose(latestRoom);
          }else{
            clearAutoClose();
            $("revealHint").textContent = "Host will start the next question…";
          }

          setToast($("playToast"), pendingForMe ? "5-streak unlocked! Choose Claim or Sabotage." : "Waiting for next question…");
        }else{
          modalOn("revealModal", false);
          modalOn("sabotageModal", false);
          setToast($("playToast"), "");
          clearAutoClose();
          $("revealHint").textContent = "Host will start the next question…";

          // reset suppression when leaving reveal
          if(latestRoom.status === "question" || latestRoom.status === "lobby" || latestRoom.status === "final"){
            suppressRevealForQ = null;
          }
        }

        // final screen
        if(latestRoom.status === "final" && me){
          const winners = latestRoom.winners || [];
          const isWinner = winners.includes(uid);
          $("finalTitle").textContent = isWinner ? "You Know It All" : "Not too bad!";
          $("finalSpark").textContent = isWinner ? "✦ ✧ ✦ ✧ ✦" : "☹";
          $("finalSub").textContent = `Final score: ${me.score||0}`;
        }

      }, (err)=>console.error("Room listener error:", err));
    }

    function hook(btnId, fn){
      $(btnId).addEventListener("click", async ()=>{
        SFX.ensureUnlocked();
        SFX.click();
        await fn();
      });
    }

    hook("btnJoin", joinGame);
    hook("btnClaim", claim20);
    hook("btnSabotage", openSabotage);
    hook("btnCheat", cheat);
    hook("btnHelp", help5050);

    $("btnCloseSab").onclick = ()=>{ SFX.ensureUnlocked(); SFX.click(); modalOn("sabotageModal", false); };

    $("btnCloseReveal").onclick = ()=>{
      SFX.ensureUnlocked(); SFX.click();
      if(latestRoom && latestRoom.status === "reveal"){
        suppressReveal(latestRoom.questionIndex);
      }else{
        modalOn("revealModal", false);
      }
    };

    $("btnRules").onclick = ()=>{
      SFX.ensureUnlocked(); SFX.click();
      fillRules();
      modalOn("rulesModal", true);
    };
    $("btnCloseRules").onclick = ()=>{
      SFX.ensureUnlocked(); SFX.click();
      modalOn("rulesModal", false);
    };

    (async function init(){
      await signInPlayer();
      if(roomId) $("roomInput").value = roomId;
    })();
  </script>
</body>
</html>
