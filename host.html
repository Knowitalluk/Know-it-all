<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Know It All? — Host</title>
  <style>
    :root{
      --bg:#070707;
      --panel:#0e0e0e;
      --panel2:#111;
      --border:#232323;
      --text:#f3f3f3;
      --muted:#bdbdbd;
      --orange:#ff7a18;
      --orange2:#ff9a3d;
      --good:#29d17d;
      --bad:#ff4b4b;
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius:20px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:radial-gradient(1200px 700px at 30% -10%, rgba(255,122,24,.18), transparent 60%),
               radial-gradient(900px 600px at 90% 0%, rgba(255,122,24,.10), transparent 65%),
               var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      min-height:100vh;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:18px 16px 30px}
    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:10px 12px;border:1px solid var(--border);border-radius:18px;
      background:linear-gradient(180deg, rgba(17,17,17,.85), rgba(10,10,10,.65));
      box-shadow:var(--shadow);
      position:sticky; top:12px; z-index:10; backdrop-filter: blur(10px);
    }
    .brand{
      display:flex;align-items:center;gap:12px;
      font-weight:900; letter-spacing:.5px;
    }
    .logo{
      width:40px;height:40px;border-radius:14px;
      background: radial-gradient(circle at 30% 30%, rgba(255,154,61,.9), rgba(255,122,24,.35) 40%, rgba(0,0,0,.5) 75%),
                  linear-gradient(180deg, rgba(255,122,24,.25), rgba(255,122,24,.06));
      border:1px solid rgba(255,122,24,.35);
      box-shadow: 0 12px 30px rgba(255,122,24,.12);
    }
    .brand .t1{font-size:18px}
    .brand .t2{font-size:12px;color:var(--muted);font-weight:700;margin-top:-2px}
    .actions{display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 12px;border-radius:999px;border:1px solid var(--border);
      background:rgba(10,10,10,.6); color:var(--muted); font-weight:800;
    }
    .btn{
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(20,20,20,.9), rgba(10,10,10,.85));
      color:var(--text);
      padding:10px 14px;border-radius:14px;
      font-weight:900; cursor:pointer;
      box-shadow: 0 10px 30px rgba(0,0,0,.3);
      transition: transform .08s ease, filter .12s ease, border-color .12s ease;
      user-select:none;
    }
    .btn:hover{filter:brightness(1.12);border-color:rgba(255,122,24,.35)}
    .btn:active{transform:translateY(1px)}
    .btn.orange{
      border-color:rgba(255,122,24,.45);
      background:linear-gradient(180deg, rgba(255,122,24,.22), rgba(10,10,10,.88));
      box-shadow: 0 14px 40px rgba(255,122,24,.12);
    }
    .btn.danger{
      border-color: rgba(255,75,75,.35);
      background: linear-gradient(180deg, rgba(255,75,75,.20), rgba(10,10,10,.88));
    }
    .btn:disabled{opacity:.45;cursor:not-allowed;filter:saturate(.6)}
    .grid{
      display:grid;gap:14px;margin-top:14px;
      grid-template-columns: 420px 1fr;
    }
    @media(max-width:980px){.grid{grid-template-columns:1fr}}
    .card{
      border:1px solid var(--border);
      border-radius: var(--radius);
      background:linear-gradient(180deg, rgba(17,17,17,.75), rgba(9,9,9,.65));
      box-shadow:var(--shadow);
      padding:14px;
    }
    .card h2{margin:6px 0 10px;font-size:16px}
    .muted{color:var(--muted)}
    .divider{height:1px;background:rgba(255,255,255,.06);margin:12px 0}
    .qrWrap{
      display:flex;gap:14px;align-items:flex-start;flex-wrap:wrap;
    }
    #qr{
      width:188px;height:188px;
      border-radius:18px;
      background:#fff;
      padding:10px;
      border:2px solid rgba(255,122,24,.85); /* border to help scanning */
      box-shadow: 0 12px 35px rgba(255,122,24,.18);
      overflow:hidden;
    }
    .small{font-size:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row > *{flex: 1 1 auto}
    input, select{
      width:100%;
      padding:11px 12px;border-radius:14px;
      border:1px solid var(--border);
      background:rgba(8,8,8,.65);
      color:var(--text);
      outline:none;
      font-weight:800;
    }

    /* Game view */
    .qTitle{
      font-size:22px;font-weight:950;letter-spacing:.3px;line-height:1.25;margin:8px 0 10px;
    }
    .answers{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    @media(max-width:720px){.answers{grid-template-columns:1fr}}
    .ansBtn{
      text-align:left;
      border-radius:16px;
      padding:12px 12px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(16,16,16,.85), rgba(8,8,8,.8));
      cursor:default;
      font-weight:900;
      color:var(--text);
      position:relative;
      min-height:50px;
    }
    .ansBtn.correct{
      border-color: rgba(41,209,125,.35);
      background: linear-gradient(180deg, rgba(41,209,125,.18), rgba(8,8,8,.85));
    }
    .ansBtn.wrong{
      opacity:.6;
    }
    .timerBig{
      font-size:28px;font-weight:950;color:var(--orange);letter-spacing:1px;
    }
    .hostControls{display:flex;gap:10px;flex-wrap:wrap}
    .hostControls .btn{flex:1 1 160px}

    /* Players list */
    .plist{display:flex;flex-direction:column;gap:8px;max-height:360px;overflow:auto;padding-right:6px}
    .pitem{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.06);
      background:rgba(10,10,10,.5);
    }
    .pname{font-weight:900}
    .psub{font-size:12px;color:var(--muted);font-weight:800}
    .pscore{font-weight:950;color:var(--orange)}
    .tag{font-size:12px;font-weight:900;color:#000;background:var(--orange);padding:4px 8px;border-radius:999px}
    .tag.bad{background:var(--bad); color:#fff}
    .tag.good{background:var(--good); color:#000}

    /* Modals */
    .modalBack{
      position:fixed;inset:0;background:rgba(0,0,0,.6);
      display:none;align-items:center;justify-content:center;z-index:999;
      padding:18px;
    }
    .modal{
      width:min(720px, 100%);
      border-radius:22px;
      border:1px solid rgba(255,122,24,.35);
      background: linear-gradient(180deg, rgba(16,16,16,.92), rgba(8,8,8,.90));
      box-shadow: 0 25px 80px rgba(0,0,0,.6);
      padding:14px;
    }
    .modal h3{margin:6px 0 6px;font-size:18px}
    .modal .modalTop{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .modal .close{width:auto}
    .lbTable{width:100%;border-collapse:collapse;margin-top:8px}
    .lbTable th,.lbTable td{padding:10px;border-bottom:1px solid rgba(255,255,255,.06);text-align:left}
    .lbTable th{color:var(--muted);font-size:12px;letter-spacing:.5px}
    .note{
      margin-top:10px;color:var(--muted);font-weight:800;font-size:12px;line-height:1.45
    }

    /* Rules floating button */
    .rulesBtn{
      position:fixed;right:16px;bottom:16px;z-index:1000;
      border-radius:999px;padding:10px 14px;
      background:linear-gradient(180deg, rgba(255,122,24,.25), rgba(10,10,10,.85));
      border:1px solid rgba(255,122,24,.45);
      font-weight:950;cursor:pointer;
      box-shadow: 0 14px 44px rgba(255,122,24,.12);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <div class="t1">Know It All?</div>
          <div class="t2">Host Screen</div>
        </div>
      </div>
      <div class="actions">
        <span class="pill" id="roomPill">Room: <b id="roomCode">—</b></span>
        <span class="pill">Players: <b id="playerCount">0</b></span>
        <button class="btn" id="btnOpenLeaderboard">Leaderboard</button>
        <button class="btn danger" id="btnResetAll" disabled>Reset Game</button>
      </div>
    </div>

    <div class="grid">
      <div class="card" id="lobbyCard">
        <h2>Startup</h2>
        <div class="muted small">Create a room, share the QR/link, then start.</div>
        <div class="divider"></div>

        <div class="row">
          <div>
            <label class="small muted">Game length</label>
            <select id="gameLength">
              <option value="50">50 questions</option>
              <option value="100">100 questions</option>
              <option value="150">150 questions</option>
            </select>
          </div>
          <div style="max-width:220px">
            <label class="small muted">Timer per question</label>
            <input id="qTime" type="text" value="20 seconds" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn orange" id="btnCreateRoom">Create Room</button>
          <button class="btn orange" id="btnStartGame" disabled>Start Game</button>
        </div>

        <div class="divider"></div>

        <div class="qrWrap">
          <div>
            <div class="small muted" style="margin-bottom:8px">Join QR</div>
            <div id="qr"></div>
          </div>
          <div style="flex:1;min-width:220px">
            <div class="small muted">Join link</div>
            <input id="joinLink" readonly value="Create a room first..." />
            <div class="row" style="margin-top:10px">
              <button class="btn" id="btnCopyLink" disabled>Copy link</button>
              <button class="btn" id="btnShareWhatsApp" disabled>Share WhatsApp</button>
              <button class="btn" id="btnShareMessenger" disabled>Share Messenger</button>
            </div>
            <div class="note">
              If “Share” doesn’t open an app, just use Copy Link and paste it into WhatsApp / Messenger.
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <h2>Players Joined</h2>
        <div class="plist" id="playersList"></div>
      </div>

      <div class="card" id="gameCard" style="display:none">
        <div class="row" style="align-items:flex-start">
          <div style="flex:1">
            <div class="muted small">Question</div>
            <div class="qTitle" id="qText">—</div>
          </div>
          <div style="text-align:right;min-width:140px">
            <div class="muted small">Timer</div>
            <div class="timerBig"><span id="timeLeft">20</span>s</div>
            <div class="muted small">Q <span id="qNum">0</span>/<span id="qTotal">0</span></div>
          </div>
        </div>

        <div class="divider"></div>

        <div class="answers" id="answersHost"></div>

        <div class="divider"></div>

        <div class="hostControls">
          <button class="btn orange" id="btnReveal" disabled>Reveal Answer</button>
          <button class="btn orange" id="btnNext" disabled>Next Question</button>
          <button class="btn danger" id="btnResetGame" disabled>Reset Room</button>
        </div>

        <div class="note">
          Tip: Reveal will show correct answer + trigger leaderboard popup on all phones.
          If someone earned a 5-streak perk, the game will pause until they choose Claim/Sabotage.
        </div>
      </div>
    </div>
  </div>

  <button class="rulesBtn" id="btnRules">Rules</button>

  <!-- Leaderboard Modal -->
  <div class="modalBack" id="lbModalBack">
    <div class="modal">
      <div class="modalTop">
        <h3>Leaderboard</h3>
        <button class="btn close" id="lbClose">Close</button>
      </div>
      <table class="lbTable" id="lbTable"></table>
      <div class="note">Scores update live. Sabotaged players can’t answer the next question.</div>
    </div>
  </div>

  <!-- Rules Modal -->
  <div class="modalBack" id="rulesBack">
    <div class="modal">
      <div class="modalTop">
        <h3>Rules & How to Play</h3>
        <button class="btn close" id="rulesClose">Close</button>
      </div>
      <div class="note" style="font-size:13px;line-height:1.55;color:#e9e9e9">
        <b>Know It All?</b> is a fast-paced live quiz for up to <b>20 players</b> per room.<br><br>

        <b>How it works</b><br>
        1) Host creates a room and shares the QR/link.<br>
        2) Players join with a nickname and wait.<br>
        3) Each question has <b>20 seconds</b>. Players pick one answer (locked in).<br>
        4) Host presses <b>Reveal</b> to show the correct answer and update scores.<br>
        5) A quick <b>Leaderboard popup</b> appears after each reveal.<br><br>

        <b>Points</b><br>
        • Speed scoring: up to <b>100 points</b> for a correct answer.<br>
        • Faster answers score higher.<br><br>

        <b>Streak Perk (5 correct in a row)</b><br>
        When a player reaches a 5-correct streak, the game pauses after the reveal until they choose:<br>
        • <b>Claim +20 points</b> OR<br>
        • <b>Sabotage</b> one player (they can’t answer the next question).<br><br>

        <b>Power Buttons (Player screen)</b><br>
        • <b>CHEAT</b> (1 use per game): instantly selects the correct answer.<br>
        • <b>HELP</b> (3 uses per game): removes 2 wrong answers (like 50/50).<br>
        • <b>CLAIM</b> / <b>SABOTAGE</b> only light up when earned by streak.<br><br>

        <b>Winning</b><br>
        After the last question, the game shows the winner(s). Host can reset the room.
      </div>
    </div>
  </div>

  <!-- QRCode lib -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <script type="module">
    // Firebase (your config)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot,
      collection, query, orderBy, getDocs, serverTimestamp, writeBatch
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyClio_l3dpOesNw6tHNLDINOjWNDea0hSk",
      authDomain: "knowitall-a47a1.firebaseapp.com",
      projectId: "knowitall-a47a1",
      storageBucket: "knowitall-a47a1.firebasestorage.app",
      messagingSenderId: "975815651315",
      appId: "1:975815651315:web:7a5e981548448b382aec86"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ---------- Utilities ----------
    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
    function makeRoomCode(){
      const chars="ABCDEFGHJKMNPQRSTUVWXYZ23456789";
      let s="";
      for(let i=0;i<5;i++) s += chars[Math.floor(Math.random()*chars.length)];
      return s;
    }
    function mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    function seededShuffle(arr, seed){
      const r = mulberry32(seed);
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(r()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function hashSeed(seed, idx){
      // deterministic per question
      return (seed * 1000003 + idx * 9176) >>> 0;
    }

    // Fetch 2000 bank (4 files)
    let BANK = null;
    async function loadBank(){
      if(BANK) return BANK;
      const files = [
        "./question_bank_part1.json",
        "./question_bank_part2.json",
        "./question_bank_part3.json",
        "./question_bank_part4.json"
      ];
      const parts = [];
      for(const f of files){
        const res = await fetch(f, { cache:"no-store" });
        if(!res.ok) throw new Error("Missing file: " + f);
        const arr = await res.json();
        if(!Array.isArray(arr)) throw new Error("Bad JSON array in " + f);
        parts.push(arr);
      }
      BANK = parts.flat();
      return BANK;
    }

    function buildChoices(question, bank, seed, qIndex){
      // pick 3 decoys from bank answers, avoid duplicates
      const r = mulberry32(hashSeed(seed, qIndex));
      const correct = String(question.answer);
      const pool = bank.filter(q => String(q.answer) !== correct).map(q => String(q.answer));
      const decoys = new Set();
      while(decoys.size < 3 && pool.length){
        const cand = pool[Math.floor(r()*pool.length)];
        if(cand && cand !== correct) decoys.add(cand);
      }
      const choices = [correct, ...Array.from(decoys).slice(0,3)];
      // shuffle choices deterministically
      for(let i=choices.length-1;i>0;i--){
        const j = Math.floor(r()*(i+1));
        [choices[i], choices[j]] = [choices[j], choices[i]];
      }
      return choices;
    }

    // ---------- UI refs ----------
    const roomCodeEl = document.getElementById("roomCode");
    const playerCountEl = document.getElementById("playerCount");
    const playersListEl = document.getElementById("playersList");

    const lobbyCard = document.getElementById("lobbyCard");
    const gameCard = document.getElementById("gameCard");

    const btnCreateRoom = document.getElementById("btnCreateRoom");
    const btnStartGame = document.getElementById("btnStartGame");
    const btnReveal = document.getElementById("btnReveal");
    const btnNext = document.getElementById("btnNext");
    const btnResetGame = document.getElementById("btnResetGame");
    const btnResetAll = document.getElementById("btnResetAll");

    const gameLengthSel = document.getElementById("gameLength");

    const qTextEl = document.getElementById("qText");
    const answersHostEl = document.getElementById("answersHost");
    const timeLeftEl = document.getElementById("timeLeft");
    const qNumEl = document.getElementById("qNum");
    const qTotalEl = document.getElementById("qTotal");

    const joinLinkEl = document.getElementById("joinLink");
    const btnCopyLink = document.getElementById("btnCopyLink");
    const btnShareWhatsApp = document.getElementById("btnShareWhatsApp");
    const btnShareMessenger = document.getElementById("btnShareMessenger");

    const lbModalBack = document.getElementById("lbModalBack");
    const lbTable = document.getElementById("lbTable");
    document.getElementById("btnOpenLeaderboard").onclick = ()=> openLeaderboardModal();
    document.getElementById("lbClose").onclick = ()=> closeLeaderboardModal();

    const rulesBack = document.getElementById("rulesBack");
    document.getElementById("btnRules").onclick = ()=> rulesBack.style.display="flex";
    document.getElementById("rulesClose").onclick = ()=> rulesBack.style.display="none";

    // ---------- Room state ----------
    let roomCode = null;
    let roomUnsub = null;
    let playersUnsub = null;
    let roomDocRef = null;
    let playersColRef = null;
    let playersCache = []; // sorted
    let tickTimer = null;

    function setLobby(enabled){
      lobbyCard.style.display = enabled ? "" : "none";
      gameCard.style.display = enabled ? "none" : "";
    }

    function baseUrl(){
      return window.location.href.replace(/host\.html.*$/,"");
    }

    function makeJoinUrl(code){
      return baseUrl() + "player.html?room=" + encodeURIComponent(code);
    }

    function renderQR(code){
      const qrEl = document.getElementById("qr");
      qrEl.innerHTML = "";
      const url = makeJoinUrl(code);
      new QRCode(qrEl, { text:url, width:168, height:168, correctLevel: QRCode.CorrectLevel.H });
    }

    // ---------- Firestore ----------
    async function createRoom(){
      const code = makeRoomCode();
      const seed = randInt(1, 2_000_000_000);
      const gameLen = parseInt(gameLengthSel.value,10);

      const bank = await loadBank(); // ensures files exist
      if(bank.length < 2000) throw new Error("Question bank not loaded (need 2000).");

      roomCode = code;
      roomDocRef = doc(db, "rooms", roomCode);
      playersColRef = collection(db, "rooms", roomCode, "players");

      await setDoc(roomDocRef, {
        createdAt: serverTimestamp(),
        status: "lobby",                // lobby | question | reveal | awaitingPerks | final
        questionCount: gameLen,         // 50/100/150
        seed,
        qIndex: 0,
        qStartMs: null,
        revealAtMs: null,
        awaitingPerkFor: [],            // array of playerIds who must choose claim/sabotage
        lastRevealSummary: null,        // { qIndex, correctAnswer, choices, revealedAtMs }
        sabotageNext: {},               // map playerId -> true (means cannot answer next)
        finishedAt: null
      });

      // UI
      roomCodeEl.textContent = roomCode;
      renderQR(roomCode);
      const url = makeJoinUrl(roomCode);
      joinLinkEl.value = url;
      btnCopyLink.disabled = false;
      btnShareWhatsApp.disabled = false;
      btnShareMessenger.disabled = false;
      btnResetAll.disabled = false;

      // Listen
      bindRoomListeners();
    }

    function bindRoomListeners(){
      if(roomUnsub) roomUnsub();
      if(playersUnsub) playersUnsub();

      roomUnsub = onSnapshot(roomDocRef, async (snap)=>{
        if(!snap.exists()) return;
        const room = snap.data();

        // Show correct UI
        setLobby(room.status === "lobby");

        qTotalEl.textContent = String(room.questionCount || 0);
        qNumEl.textContent = String((room.qIndex||0) + (room.status==="final"?0:1));

        // Start button enable only if players >= 1
        btnStartGame.disabled = !(playersCache.length >= 1 && room.status === "lobby");

        btnResetGame.disabled = false;
        btnReveal.disabled = !(room.status === "question");
        btnNext.disabled = !(room.status === "reveal" || room.status === "awaitingPerks");

        // render game question if in question/reveal/awaitingPerks
        if(room.status !== "lobby"){
          await renderHostQuestion(room);
        }

        // timer UI (host uses qStartMs as source)
        syncHostTimer(room);
      });

      playersUnsub = onSnapshot(query(playersColRef, orderBy("score","desc")), (snap)=>{
        playersCache = snap.docs.map(d=>({ id:d.id, ...d.data() }));
        playerCountEl.textContent = String(playersCache.length);
        renderPlayersList(playersCache);
        renderLeaderboardTable(playersCache);
        // update start button condition
        if(roomCode && roomDocRef){
          // room listener handles state, but keep start enabled fresh:
          // (it will be set properly when room snapshot arrives)
        }
      });
    }

    async function renderHostQuestion(room){
      const bank = await loadBank();
      const order = seededShuffle(bank, room.seed).slice(0, room.questionCount);
      const qIndex = room.qIndex || 0;
      const q = order[Math.min(qIndex, order.length-1)];
      if(!q){ qTextEl.textContent = "No question loaded."; return; }

      qTextEl.textContent = q.text;

      const choices = buildChoices(q, order, room.seed, qIndex);
      answersHostEl.innerHTML = "";

      const reveal = (room.status === "reveal" || room.status === "awaitingPerks" || room.status === "final");
      const correct = String(q.answer);

      choices.forEach((choice)=>{
        const div = document.createElement("div");
        div.className = "ansBtn";
        div.textContent = choice;

        if(reveal){
          if(choice === correct){
            div.classList.add("correct");
          } else {
            div.classList.add("wrong");
          }
        }
        answersHostEl.appendChild(div);
      });

      // if final, show winner card in lobby modal style? (handled via leaderboard modal)
      if(room.status === "final"){
        openLeaderboardModal(true);
      }
    }

    function syncHostTimer(room){
      if(tickTimer) clearInterval(tickTimer);

      if(room.status === "question" && room.qStartMs){
        tickTimer = setInterval(()=>{
          const now = Date.now();
          const left = Math.max(0, Math.ceil((room.qStartMs + 20000 - now)/1000));
          timeLeftEl.textContent = String(left);
        }, 200);
      } else {
        timeLeftEl.textContent = "20";
      }
    }

    function renderPlayersList(players){
      playersListEl.innerHTML = "";
      if(players.length === 0){
        const d = document.createElement("div");
        d.className="muted small";
        d.textContent="No players yet. Share the QR/link.";
        playersListEl.appendChild(d);
        return;
      }
      players.forEach(p=>{
        const row = document.createElement("div");
        row.className = "pitem";
        const left = document.createElement("div");
        left.innerHTML = `<div class="pname">${escapeHtml(p.nick||"Player")}</div>
                          <div class="psub">Streak: ${p.streak||0} • Cheat: ${(p.cheatUsed? "used":"ready")} • Help: ${p.helpUsed||0}/3</div>`;
        const right = document.createElement("div");
        const sabotaged = p.sabotagedNext ? `<span class="tag bad">SABOTAGED</span>` : "";
        right.innerHTML = `<div class="pscore">${p.score||0}</div>${sabotaged}`;
        row.appendChild(left);
        row.appendChild(right);
        playersListEl.appendChild(row);
      });
    }

    function openLeaderboardModal(isFinal=false){
      lbModalBack.style.display="flex";
      // Title tweak if final
      lbModalBack.querySelector("h3").textContent = isFinal ? "Final Leaderboard" : "Leaderboard";
    }
    function closeLeaderboardModal(){
      lbModalBack.style.display="none";
    }

    function renderLeaderboardTable(players){
      const rows = [];
      rows.push(`<tr><th>Rank</th><th>Player</th><th>Score</th><th>Status</th></tr>`);
      players.forEach((p,i)=>{
        const st = p.sabotagedNext ? `<span class="tag bad">Sabotaged</span>` : (p.pendingPerk ? `<span class="tag">Perk</span>` : `<span class="tag good">OK</span>`);
        rows.push(`<tr>
          <td>${i+1}</td>
          <td>${escapeHtml(p.nick||"Player")}</td>
          <td><b style="color:var(--orange)">${p.score||0}</b></td>
          <td>${st}</td>
        </tr>`);
      });
      lbTable.innerHTML = rows.join("");
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    // ---------- Game flow ----------
    async function startGame(){
      if(!roomDocRef) return;
      const snap = await getDoc(roomDocRef);
      if(!snap.exists()) return;
      const room = snap.data();
      if(room.status !== "lobby") return;

      // clear scores/streaks for clean start
      const batch = writeBatch(db);
      const pSnap = await getDocs(playersColRef);
      pSnap.forEach(d=>{
        batch.update(d.ref, {
          score: 0,
          streak: 0,
          lastAnswer: null,
          lastAnswerMs: null,
          lastCorrect: null,
          cheatUsed: false,
          helpUsed: 0,
          pendingPerk: false,
          sabotagedNext: false
        });
      });

      batch.update(roomDocRef, {
        status: "question",
        qIndex: 0,
        qStartMs: Date.now(),
        revealAtMs: null,
        awaitingPerkFor: [],
        lastRevealSummary: null,
        sabotageNext: {},
        finishedAt: null
      });
      await batch.commit();
    }

    async function revealAnswer(){
      // Host reveals current question, awards points, triggers perk pause if needed
      const snap = await getDoc(roomDocRef);
      if(!snap.exists()) return;
      const room = snap.data();
      if(room.status !== "question") return;

      const bank = await loadBank();
      const order = seededShuffle(bank, room.seed).slice(0, room.questionCount);
      const qIndex = room.qIndex || 0;
      const q = order[qIndex];
      const correct = String(q.answer);
      const choices = buildChoices(q, order, room.seed, qIndex);

      // Read all players
      const pSnap = await getDocs(playersColRef);
      const batch = writeBatch(db);

      const awaiting = [];

      pSnap.forEach(docSnap=>{
        const pid = docSnap.id;
        const p = docSnap.data();
        const answer = p.lastAnswer;        // chosen option text
        const answerMs = p.lastAnswerMs;    // ms timestamp when clicked
        const sabotaged = !!p.sabotagedNext;

        let lastCorrect = false;
        let scoreAdd = 0;
        let newStreak = p.streak || 0;

        if(!sabotaged && answer != null){
          lastCorrect = (String(answer) === correct);
          if(lastCorrect){
            // Speed points: max 100, based on time left at click
            // timeLeft = clamp(0..20)
            const start = room.qStartMs || Date.now();
            const elapsed = Math.max(0, Math.min(20000, (answerMs||Date.now()) - start));
            const timeLeft = Math.max(0, 20000 - elapsed);
            scoreAdd = Math.round(100 * (timeLeft / 20000));
            newStreak += 1;
          } else {
            newStreak = 0;
          }
        } else {
          // no answer or sabotaged => streak reset
          lastCorrect = false;
          newStreak = 0;
        }

        const updates = {
          lastCorrect,
          score: (p.score||0) + scoreAdd,
          streak: newStreak,
          pendingPerk: false, // set below if needed
        };

        // If hit 5-streak now, mark pending perk
        if(newStreak > 0 && newStreak % 5 === 0 && lastCorrect){
          updates.pendingPerk = true;
          awaiting.push(pid);
        }

        // Clear answer for next question
        updates.lastAnswer = null;
        updates.lastAnswerMs = null;

        // Clear sabotage flag AFTER it took effect this question (we block answering on player side; host also treats it)
        updates.sabotagedNext = false;

        batch.update(docSnap.ref, updates);
      });

      // Move room to reveal, and if perks exist => awaitingPerks
      const nextStatus = awaiting.length ? "awaitingPerks" : "reveal";

      batch.update(roomDocRef, {
        status: nextStatus,
        revealAtMs: Date.now(),
        lastRevealSummary: {
          qIndex,
          correctAnswer: correct,
          choices,
          revealedAtMs: Date.now()
        },
        awaitingPerkFor: awaiting
      });

      await batch.commit();
    }

    async function nextQuestion(){
      const snap = await getDoc(roomDocRef);
      if(!snap.exists()) return;
      const room = snap.data();

      if(room.status !== "reveal" && room.status !== "awaitingPerks") return;

      // if awaitingPerks, host cannot proceed until all resolved
      if(room.status === "awaitingPerks" && (room.awaitingPerkFor||[]).length){
        alert("Waiting for streak selection(s) before continuing.");
        return;
      }

      const nextIndex = (room.qIndex||0) + 1;
      if(nextIndex >= (room.questionCount||0)){
        await updateDoc(roomDocRef, { status:"final", finishedAt: Date.now() });
        openLeaderboardModal(true);
        return;
      }

      // sabotageNext map applies to next question
      // room.sabotageNext is map of playerId->true that should be applied to player doc flags
      const sabotageNext = room.sabotageNext || {};

      // apply sabotage to target players
      const pSnap = await getDocs(playersColRef);
      const batch = writeBatch(db);
      pSnap.forEach(d=>{
        if(sabotageNext[d.id]){
          batch.update(d.ref, { sabotagedNext: true });
        }
      });

      batch.update(roomDocRef, {
        status: "question",
        qIndex: nextIndex,
        qStartMs: Date.now(),
        revealAtMs: null,
        lastRevealSummary: null,
        sabotageNext: {} // consumed
      });
      await batch.commit();
    }

    async function resetRoom(){
      if(!roomDocRef) return;
      if(!confirm("Reset the room? This clears scores and returns to lobby.")) return;

      const pSnap = await getDocs(playersColRef);
      const batch = writeBatch(db);
      pSnap.forEach(d=>{
        batch.update(d.ref,{
          score:0, streak:0,
          lastAnswer:null, lastAnswerMs:null, lastCorrect:null,
          cheatUsed:false, helpUsed:0,
          pendingPerk:false, sabotagedNext:false
        });
      });
      batch.update(roomDocRef,{
        status:"lobby",
        qIndex:0,
        qStartMs:null,
        revealAtMs:null,
        awaitingPerkFor:[],
        lastRevealSummary:null,
        sabotageNext:{},
        finishedAt:null
      });
      await batch.commit();

      setLobby(true);
    }

    async function hardResetAll(){
      if(!roomDocRef) return;
      if(!confirm("Hard reset: remove room and all players?")) return;

      // simplest: reset room only (delete requires more rules). We'll reset.
      await resetRoom();
    }

    // ---------- Share ----------
    function shareMessage(url){
      return `Just started a quiz game “Know It All?” — fancy joining in?\n${url}`;
    }
    btnCopyLink.onclick = async ()=>{
      const url = joinLinkEl.value;
      await navigator.clipboard.writeText(url);
      alert("Link copied!");
    };
    btnShareWhatsApp.onclick = ()=>{
      const url = joinLinkEl.value;
      const msg = encodeURIComponent(shareMessage(url));
      window.open(`https://wa.me/?text=${msg}`, "_blank");
    };
    btnShareMessenger.onclick = ()=>{
      const url = joinLinkEl.value;
      // Messenger share (web). If it doesn't open app, users can copy link.
      const shareUrl = encodeURIComponent(url);
      window.open(`https://www.facebook.com/dialog/send?link=${shareUrl}`, "_blank");
      // Note: FB dialog may require app params in some cases; copy link is always fallback.
    };

    // ---------- Buttons ----------
    btnCreateRoom.onclick = async ()=>{
      try{
        btnCreateRoom.disabled = true;
        await createRoom();
      }catch(e){
        console.error(e);
        alert("Create room failed: " + e.message);
      }finally{
        btnCreateRoom.disabled = false;
      }
    };
    btnStartGame.onclick = ()=> startGame().catch(e=>alert(e.message));
    btnReveal.onclick = ()=> revealAnswer().catch(e=>alert(e.message));
    btnNext.onclick = ()=> nextQuestion().catch(e=>alert(e.message));
    btnResetGame.onclick = ()=> resetRoom().catch(e=>alert(e.message));
    btnResetAll.onclick = ()=> hardResetAll().catch(e=>alert(e.message));
  </script>
</body>
</html>
